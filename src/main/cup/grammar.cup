import java_cup.runtime.Symbol;
import java.util.List;
import java.util.ArrayList;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import ast.*;

parser code
{:
    private static final Logger LOGGER = LoggerFactory.getLogger(parser.class);

    /** Report a non fatal error (or warning).
     *
     * @param message an error message.
     * @param info    an extra object reserved for use by specialized subclasses.
     */
    public void report_error(String message, Object info)
    {
        String error = "";
        if (!(info instanceof Symbol))
            info = cur_token;
        if(info instanceof Symbol) {
            int line = ((Symbol)info).left;
            int column = ((Symbol)info).right;
            error = line  + ":" + column;
        }
        error += ": " + message;
        LOGGER.error(error);
    }

    /** Report a fatal error.
     *
     * @param message an error message.
     * @param info    an extra object reserved for use by specialized subclasses.
     */
    public void report_fatal_error(String   message, Object   info) throws java.lang.Exception
    {
        /* stop parsing (not really necessary since we throw an exception, but) */
        done_parsing();

        /* use the normal error message reporting to put out the message */
        report_error(message, info);

        /* throw an exception */
        throw new Exception("Can't recover from previous error(s)");
    }

    public int getLine() {
        Symbol symbol = (Symbol) cur_token;
        return symbol.left;
    }

    public int getColumn() {
        Symbol symbol = (Symbol) cur_token;
        return symbol.right;
    }
:};

/*Terminals*/
terminal THIS,NULL,NEW;
terminal DO, WHILE;
terminal LPAREN, RPAREN;
terminal LBRACKET, RBRACKET;
terminal GREATER, GREATER_EQ, LESS, LESS_EQ;
terminal EQUAL, NOT_EQUAL, NOT, ASSIGN;
terminal TIMES, DIVISION, MOD;
terminal PLUS, MINUS, UMINUS;
terminal IF,ELSE;
terminal DOT,COMMA, SEMICOLON;
terminal AND, OR;
terminal RETURN, BREAK, CONTINUE;
terminal NUMBER, STRING, VOID, CLASS;

terminal java.lang.Integer INTEGER_LITERAL;
terminal java.lang.Double  DOUBLE_LITERAL;
terminal java.lang.String  STRING_LITERAL;
terminal java.lang.String IDENTIFIER;


/*Non Terminals*/
non terminal Expression Expr;
non terminal Statement Stmt;
non terminal StatementList StmtList;
non terminal CompilationUnit CompilationUnit;
non terminal CompoundStatement CompoundStmt;
non terminal ExpressionList ExprList;
non terminal ClassDefinition ClassDefinition;
non terminal ClassDefinitionList ClassDefinitionList;
non terminal FieldOrFunctionDefinition FieldOrFunctionDefinition;
non terminal FieldOrFunctionDefinitionList FieldOrFunctionDefinitionList;
non terminal FieldDefinition FieldDefinition;
non terminal FunctionDefinition FunctionDefinition;
non terminal FunctionDefinitionList FunctionDefinitionList;
non terminal ParameterList ParameterList;
non terminal ParameterDeclaration ParameterDeclaration;
non terminal TypeSpecifier TypeSpecifier;

/*Precedence of operators*/
precedence left OR;
precedence left AND;
precedence left EQUAL, NOT_EQUAL;
precedence left LESS, LESS_EQ, GREATER, GREATER_EQ;
precedence left PLUS, MINUS;
precedence left TIMES, DIVISION, MOD;
precedence right NEW;
precedence right UMINUS, NOT;
precedence left LPAREN, RPAREN, DOT;

/*Grammar*/
start with CompilationUnit;

CompilationUnit ::= /*empty*/
                    {:
                        RESULT = new CompilationUnit();
                        RESULT.setLine(0);
                        RESULT.setColumn(0);
                    :}
                 | ClassDefinitionList:cdl
                    {:
                        RESULT = new CompilationUnit(cdl);
                        RESULT.setLine(cdlleft);
                        RESULT.setColumn(cdlright);
                    :}
                 | FunctionDefinitionList:fdl
                    {:
                        RESULT = new CompilationUnit(fdl);
                        RESULT.setLine(fdlleft);
                        RESULT.setColumn(fdlright);
                    :}
                  ;

ClassDefinition ::= CLASS IDENTIFIER:i LBRACKET RBRACKET
                    {:
                        RESULT = new ClassDefinition(i);
                        RESULT.setLine(ileft);
                        RESULT.setColumn(iright);
                    :}
                  | CLASS IDENTIFIER:i LBRACKET FieldOrFunctionDefinitionList:fofdl RBRACKET
                    {:
                        RESULT = new ClassDefinition(i,fofdl);
                        RESULT.setLine(ileft);
                        RESULT.setColumn(iright);
                    :}
                  ;

ClassDefinitionList ::= ClassDefinition:c
                        {:
                            RESULT = new ClassDefinitionList();
                            RESULT.addClassDefinition(c);
                            RESULT.setLine(cleft);
                            RESULT.setColumn(cright);
                        :}
                      | ClassDefinitionList ClassDefinition:c
                        {:
                            RESULT.addClassDefinition(c);
                        :}
                      | ClassDefinitionList FunctionDefinition:f
                        {:
                            RESULT.addFunctionDefinition(f);
                        :}
                      ;

FieldOrFunctionDefinition ::= FieldDefinition:fd
                              {:
                                RESULT = new FieldOrFunctionDefinition();
                                RESULT.setFieldDef(fd);
                                RESULT.setLine(fdleft);
                                RESULT.setColumn(fdright);
                              :}
                            | FunctionDefinition:fd
                              {:
                                RESULT.setFunctionDef(fd);
                                RESULT.setLine(fdleft);
                                RESULT.setColumn(fdright);
                              :}
                            ;

FieldOrFunctionDefinitionList ::= FieldOrFunctionDefinition
                                | FieldOrFunctionDefinitionList FieldOrFunctionDefinition
                                ;

FieldDefinition ::= TypeSpecifier:ts IDENTIFIER:i SEMICOLON
                    {:
                        RESULT = new FieldDefinition(ts,i);
                        RESULT.setLine(tsleft);
                        RESULT.setColumn(tsright);
                    :}
                  ;

FunctionDefinition ::= TypeSpecifier:t IDENTIFIER:i LPAREN ParameterList:pl RPAREN CompoundStmt:cs
                       {:
                            RESULT = new FunctionDefinition(t,i,pl,cs);
                            RESULT.setLine(tleft);
                            RESULT.setColumn(tright);
                       :}
                     ;

FunctionDefinitionList ::= FunctionDefinition
                         | FunctionDefinitionList FunctionDefinition
                         | FunctionDefinitionList ClassDefinition
                         ;

ParameterList ::= /*empty*/
                | ParameterDeclaration
                | ParameterList COMMA ParameterDeclaration
                ;

ParameterDeclaration ::= TypeSpecifier:ts IDENTIFIER:i
                         {:
                            RESULT = new ParameterDeclaration(ts,i);
                            RESULT.setLine(tsleft);
                            RESULT.setColumn(tsright);
                         :}
                       ;

TypeSpecifier ::= NUMBER:n
                  {:
                    RESULT = new TypeSpecifier("number");
                    RESULT.setLine(nleft);
                    RESULT.setColumn(nright);
                  :}
                | STRING:s
                  {:
                    RESULT = new TypeSpecifier("string");
                    RESULT.setLine(sleft);
                    RESULT.setColumn(sright);
                  :}
                | VOID:v
                  {:
                    RESULT = new TypeSpecifier("void");
                    RESULT.setLine(vleft);
                    RESULT.setColumn(vright);
                  :}
                | IDENTIFIER:i
                  {:
                    RESULT = new TypeSpecifier(i);
                    RESULT.setLine(ileft);
                    RESULT.setColumn(iright);
                  :}
                ;

CompoundStmt ::= LBRACKET RBRACKET
               | LBRACKET StmtList RBRACKET
               ;

Stmt ::= WHILE LPAREN Expr RPAREN Stmt
       | IF LPAREN Expr RPAREN Stmt
       | IF LPAREN Expr RPAREN Stmt ELSE Stmt
       | Expr ASSIGN Expr SEMICOLON
       | Expr SEMICOLON
       | RETURN Expr SEMICOLON
       | BREAK SEMICOLON
       | CONTINUE SEMICOLON
       | CompoundStmt
       | TypeSpecifier IDENTIFIER SEMICOLON
       | DO CompoundStmt WHILE LPAREN Expr RPAREN SEMICOLON
       ;

StmtList ::= Stmt
           | StmtList Stmt
           ;

Expr ::= /*empty*/
       | INTEGER_LITERAL
       | DOUBLE_LITERAL
       | STRING_LITERAL
       | THIS
       | NULL
       | IDENTIFIER
       | IDENTIFIER LPAREN ExprList RPAREN
       | NEW IDENTIFIER LPAREN ExprList RPAREN
       | Expr DOT IDENTIFIER
       | Expr DOT IDENTIFIER LPAREN ExprList RPAREN
       | LPAREN Expr RPAREN
       | Expr PLUS Expr
       | Expr MINUS Expr
       | Expr TIMES Expr
       | Expr DIVISION Expr
       | Expr MOD Expr
       | Expr EQUAL Expr
       | Expr NOT_EQUAL Expr
       | NOT Expr
       | Expr LESS Expr
       | Expr LESS_EQ Expr
       | Expr GREATER Expr
       | Expr GREATER_EQ Expr
       | Expr AND Expr
       | Expr OR Expr
       | MINUS Expr %prec UMINUS
       ;

ExprList ::= Expr
           | ExprList COMMA Expr
          ;
